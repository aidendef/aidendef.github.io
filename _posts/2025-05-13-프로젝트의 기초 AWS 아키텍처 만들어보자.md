---

title: "이쁨 받는 AWS 아키텍처 만들어보자"
date: 2025-05-12 00:00:00 +0900
categories: [cloud, ai, Business]
tags: [AWS, AI, Bedrock, Sagemaker, Architecture, Cloud]
sidebar:
  nav: "docs"
toc: true
toc_sticky: true
# classes: wide
excerpt : 이쁨받는 AWS 아키텍처 만드는 7가지 원칙
header:
  teaser: /assets/images/post_img/archi-sample.png

---

## 1. 들어가며

클라우드 환경에서의 아키텍처 설계는 단순히 서비스를 배치하는 것을 넘어, 확장성, 안정성, 비용 효율성까지 고려한 종합 설계이다.
하지만 처음 시작할 때는 수많은 AWS 서비스들 사이에서 무엇을 선택해야 할지, 어떻게 조합해야 할지 막막할 수밖에 없다.

이 글에서는 복잡한 이론 대신, 실제 현업에서도 이쁨(?) 받는 AWS 아키텍처를 만드는 실전 방식을 공유하려고 합니다.
단순히 구성도를 예쁘게 그리는 것이 아니라, 기능적으로 명확하고 운영팀과 개발팀 모두가 이해하기 쉬운 구조를 목표로 해보려고 한다.

![샘플](/assets/images/post_img/archi-sample.png)


## 2. 실전에서 통하는 AWS 아키텍처 설계 7가지 원칙

### 2.1 요구사항 기반 설계

좋은 아키텍처는 멋진 기술 스택에서 나오지 않는다. **비즈니스와 사용자 요구사항을 얼마나 정확히 반영했는가**에서 시작된다.

아키텍처 설계 초기에 가장 먼저 할 일은 **“이 시스템이 풀고자 하는 문제는 무엇인가?”**를 구체적으로 정의하는 것이다. 예를 들어 교육 플랫폼을 만든다면 단순한 로그인/회원가입 시스템만이 아니라 **“학생의 현재 지식 수준을 분석하고, 다음 학습 단계를 예측할 수 있어야 한다”**는 요구가 핵심이 될 수 있다.

이때 다음과 같은 세 가지 질문을 던져야 한다.

1.  **누가 사용하는가?**    
    *   학생인가? 교사인가? 관리자인가?        
2.  **무엇을 기대하는가?**    
    *   진단 평가인가? 실시간 피드백인가? 학습 경로 추천인가?        
3.  **어떤 흐름으로 동작해야 하나?**    
    *   사용자가 처음 접속한 순간부터, 결과를 받아보기까지의 흐름을 그려봐야 한다.
        

요구사항을 제대로 이해하면, 그에 맞춰 아키텍처도 달라진다. 예를 들어, 실시간 응답이 중요한 경우에는 API Gateway + Lambda 구조에 캐싱 계층(ElastiCache)을 두는 것이 적절하고, 대용량 분석이 중심이라면 Athena, Glue, EMR이 전면에 나와야 한다.

**요구사항을 기능과 비기능으로 나누어 정리해두면**, 아키텍처 판단 기준이 훨씬 명확해진다.

| 구분 | 내용 |
| --- | --- |
| 기능 요구사항 | 학습 경로 추천, 진단 분석, 실시간 피드백 |
| 비기능 요구사항 | 높은 가용성, 낮은 응답 시간, 확장성, 보안 |

요약하자면, **요구사항 기반 설계란 복잡한 기술 용어 대신 ‘무엇을 왜 하려는지’에 집중하는 방식이다.** AWS의 수많은 서비스를 선택하기 전에, 어떤 문제를 풀려는지 먼저 정의해야 한다.

### 2.2 계층 분리 및 최소 책임 원칙 적용

서비스가 커질수록 유지보수가 어려워지는 가장 큰 이유는 **모든 계층이 서로 얽혀 있기 때문**이다.  
이런 상황을 방지하려면 시스템을 명확히 나눠야 한다. 흔히 말하는 **"계층 분리"**는 단순한 구성도상의 분리가 아니라, **책임의 분리**를 의미한다.

* * *

#### 1) 왜 계층을 나눠야 할까?
*   프론트엔드와 백엔드가 서로 독립적으로 개발되도록    
*   인증/권한 로직이 비즈니스 로직과 섞이지 않도록    
*   데이터 저장소 변경이 전체 시스템에 영향을 주지 않도록
    

예를 들어 Lambda 함수가 API 요청도 받고, 인증도 하고, DB 저장까지 다 한다면 하나가 실패했을 때 디버깅도 어렵고 확장성도 떨어진다.

* * *

#### 2) 어떻게 나눠야 할까?

아래는 대표적인 계층 분리 방식이다:

| 계층 | 역할 |
| --- | --- |
| **프론트엔드 계층** | 사용자 인터페이스 제공 (S3 + CloudFront) |
| **API 계층** | 클라이언트와 서버 간 통신 처리 (API Gateway + Lambda) |
| **비즈니스 로직 계층** | 도메인 핵심 로직 구현 (Lambda 또는 ECS/Fargate) |
| **데이터 저장 계층** | 상태 저장 및 조회 (DynamoDB, RDS, S3 등) |
| **AI/ML 계층** | 예측, 추천, 요약 등 모델 활용 (Bedrock, SageMaker) |
| **분석 및 ETL 계층** | 로그 수집, 배치 처리, 분석 (Glue, Athena, EMR 등) |

* * *

#### 3) SRP (Single Responsibility Principle) 적용

각 계층 안에서도 **하나의 책임만 수행**하도록 세분화하는 것이 핵심이다. 예를 들어:

*   `회원가입` Lambda는 오직 회원 가입만 처리해야 한다.    
*   `학습 진단` Lambda는 진단 로직만 포함해야 한다. 인증 검증은 따로 처리해야 한다.
    

이렇게 구성하면 오류가 나더라도 해당 책임 범위 안에서만 해결하면 된다.

* * *

#### 4) 실전에서 적용하는 팁

*   **API Gateway → Lambda 매핑은 1:1**을 유지하자  
    하나의 Lambda에 여러 엔드포인트를 몰아넣는 순간, SRP가 무너진다.    
*   **Lambda가 너무 커지면 컨테이너로 전환을 고려하자**  
    Fargate/ECS로 나누고, 내부는 모듈화해서 관리    
*   **모든 Lambda는 CloudWatch 로그 외에 X-Ray 트레이싱도 추가하자**  
    계층 간 성능 병목이 보인다.
    

* * *

요약하자면, **계층 분리란 아키텍처를 단순화하는 기술이 아니라, 팀 전체의 유지보수 비용을 줄이는 구조적 전략이다.**  
AWS에서는 이 구조를 자연스럽게 녹여낼 수 있는 서비스들이 많으니, 역할에 맞는 서비스를 택하면 된다.


### 2.3 서버리스 우선 전략

초기 서비스 설계 시 **서버리스 아키텍처를 우선 고려하는 것**은, 비용과 운영 복잡도를 동시에 줄일 수 있는 가장 강력한 전략 중 하나다.

서버리스는 단순히 EC2 대신 Lambda를 쓰는 걸 의미하는 게 아니라, **인프라 관리 부담 없이 핵심 로직 구현에 집중하는 구조**를 말한다.

* * *

#### 1) 왜 서버리스를 우선으로 생각해야 할까?

*   **관리할 인프라가 없다:** EC2처럼 서버 설치, 패치, 유지보수 필요 없음    
*   **초기 비용이 낮다:** 사용한 만큼만 과금되기 때문에 테스트/베타 단계에서 특히 유리    
*   **자동 확장:** 트래픽 급증에도 대응 가능    
*   **빠른 배포와 롤백:** 코드 하나 바꾸고 바로 배포 가능 (CI/CD와 찰떡)
    

* * *

#### 2) AWS에서 서버리스로 가능한 구성

| 목적 | 서버리스 서비스 |
| --- | --- |
| API 처리 | API Gateway + Lambda |
| 사용자 인증 | Amazon Cognito |
| 파일 저장 | Amazon S3 |
| 메시지 큐 | Amazon SQS |
| 이벤트 기반 워크플로우 | Amazon EventBridge + Step Functions |
| 데이터베이스 | Amazon DynamoDB |
| 모델 추론 | Amazon Bedrock (서버리스 추론 API) |

이 조합만으로도 완전한 SaaS, 학습 플랫폼, 데이터 파이프라인까지 구축할 수 있다.

* * *

#### 3) 서버리스 설계 시 유의할 점

*   **콜드 스타트 고려:** 특히 VPC 내부에서 실행하는 Lambda는 초기 지연이 있을 수 있음  
    → 해결: Lambda SnapStart, Arm 기반 Lambda, 내부 호출에선 Provisioned Concurrency 설정    
*   **짧은 실행 시간에 최적화된 로직 작성 필요:**  
    Lambda는 최대 15분 제한이 있으므로, 긴 작업은 Step Functions나 Fargate로 위임    
*   **비동기 설계에 익숙해져야 함:**  
    SQS, SNS, EventBridge 등으로 이벤트 흐름을 연결하는 방식이 기본
    

* * *

#### 4) 서버리스가 적합하지 않은 상황

*   **지속적으로 CPU/메모리를 점유해야 하는 작업**    
*   **고성능 GPU 기반의 학습/추론**    
*   **밀리초 단위 응답이 필요한 초저지연 API**
    

이런 경우에는 EC2, ECS, EKS 등 컨테이너 기반 구성이 적합하다.

* * *

서버리스 우선 전략은 **작은 팀, 빠른 시작, 명확한 기능**이 핵심일 때 강력한 무기다.  
AWS는 이를 위해 수많은 관리형 서비스를 제공하고 있으니, **직접 서버를 띄우는 일은 정말 필요할 때만 하자.**


### 2.4 데이터 흐름 기반 설계

많은 시스템 설계가 **기능 중심**으로 시작되지만, 시간이 지나면 **데이터 흐름**이 구조의 복잡성을 좌우하게 된다.  
그래서 초기부터 “**어떤 데이터가, 어디서 생성되어, 어디로 흘러가는가**”를 기준으로 아키텍처를 잡아야 한다.

* * *

#### 1) 데이터 흐름이 중요한 이유

*   **기능보다 데이터가 오래 남는다:** 기능은 변경되거나 제거되지만, 데이터는 보존되어야 하고 분석 대상이 된다.    
*   **복잡성은 데이터 이동에서 생긴다:** 특히 AI/ML 시스템이나 분석 시스템에선 데이터가 수집→저장→처리→활용으로 이어지는 전체 흐름이 중요하다.    
*   **보안과 규정 준수도 흐름을 기준으로 설계해야 한다:** 예: 개인정보가 어떤 경로를 거치는지 명확히 해야 DLP(Data Loss Prevention)나 암호화 포인트를 설정할 수 있음.
    

* * *

#### 2) 실제 예시: 학습 플랫폼의 데이터 흐름

```plaintext
사용자 행동 → API Gateway → Lambda → DynamoDB 저장
                                      ↓
                         Amazon EventBridge
                                      ↓
                     Glue/EMR로 ETL 처리
                                      ↓
               Athena + QuickSight로 시각화
```

여기서 중요한 건, 단순히 “어디에 저장할까?”가 아니라  
→ **어떤 데이터가 언제 생성되고, 누가 이 데이터를 쓰는가?**

* * *

#### 3) 흐름 중심 설계 체크리스트

| 항목 | 체크포인트 |
| --- | --- |
| 생성 | 데이터는 언제, 어떤 이벤트에서 생성되는가? |
| 저장 | 정형/비정형 여부에 따라 적절한 저장소인가? (RDS, S3, DynamoDB 등) |
| 처리 | 실시간/배치/스케줄 중 어떤 방식인가? |
| 활용 | 이 데이터를 누가, 어떻게 활용하는가? (API 응답, 모델 학습, 분석 리포트 등) |
| 수명주기 | 언제까지 보관되고, 어떻게 삭제되는가? |

* * *

#### 4) AWS에서 활용할 수 있는 흐름 설계 도구들

*   **EventBridge:** 데이터 흐름 중심 이벤트 라우팅    
*   **Step Functions:** 흐름을 시각적으로 구성하고 상태 기반 전환    
*   **Kinesis / MSK:** 실시간 데이터 스트림 처리    
*   **Glue Data Catalog:** 데이터 계보 및 흐름 추적
    

* * *

데이터 흐름 기반 설계는 **“무엇을 만들까?”가 아니라 “어떤 데이터가 어떻게 움직이는가?”를 먼저 생각하는 설계 방식**이다.  
이 접근법을 쓰면 기능 변경에도 데이터 기반 구조는 유지되기 때문에 확장성과 유연성이 높아진다.



### 2.5 보안 및 운영 관점 포함

AWS 아키텍처에서 **보안(Security)**과 **운영(Operations)**은 설계의 마지막이 아니라 **처음부터 함께 고려해야 할 기본 조건**이다.  
개발자 입장에서 기능 구현에 집중하다 보면 보안과 운영은 뒷전이 되기 쉬운데, 이는 나중에 큰 장애나 사고로 돌아온다.

* * *

#### 1) 보안은 "기능"이 아니라 "기준"이다

보안은 단일 기능이 아니라, **모든 계층에 스며들어 있어야 하는 기준**이다.

| 계층 | 고려 사항 |
| --- | --- |
| S3 | 퍼블릭 접근 차단, 버킷 정책 최소화, 암호화 기본 |
| Lambda | VPC 내부 실행 여부, IAM Role 최소 권한 원칙 적용 |
| API Gateway | 인증 토큰 필수, WAF 설정 |
| DynamoDB | KMS 암호화 활성화, 테이블 접근 권한 최소화 |
| Bedrock/SageMaker | 민감 데이터 입력 필터링, 결과 로그 보관 정책 설정 |

* * *

#### 2) 최소 권한 원칙 (Principle of Least Privilege)

모든 IAM Role, Policy, User, Group은 **딱 필요한 리소스, 필요한 작업만 허용**해야 한다.

예:

```yaml
Effect: Allow
Action: s3:GetObject
Resource: arn:aws:s3:::my-bucket/specific-folder/*
```

이런 식으로 리소스와 액션을 구체적으로 제한해야 한다.  
“모든 S3 액세스 허용” 같은 broad 권한은 실제 서비스에선 절대 쓰면 안 된다.

* * *

#### 3) 운영 관점의 필수 요소들

*   **모니터링:**  
    CloudWatch로 모든 Lambda, API, DB, ML Endpoint의 로그와 메트릭 수집    
*   **로깅:**  
    CloudTrail로 모든 API 호출 기록  
    S3/Bedrock 등은 별도 access log 활성화    
*   **알림:**  
    SNS, Slack 연동 또는 EventBridge + Lambda로 운영 알림 자동화    
*   **배포 전략:**  
    CodePipeline, CodeDeploy로 Canary/Rollback 전략 수립
*   **지속적인 점검:**  
    AWS Config + Security Hub로 규정 준수 및 보안 상태 점검
    

* * *

#### 4) 예: 학습 플랫폼의 보안 구성

*   Cognito에서 로그인 토큰 발급    
*   API Gateway에서 JWT 검증 및 사용자 인증    
*   Lambda는 사용자 Role에 따라 DynamoDB 조회만 허용    
*   Bedrock은 민감한 질문 내용 로그 필터링 후 저장    
*   CloudWatch에서 비정상 응답률 알림 발생 시 Slack으로 전송
    

* * *

결국 **좋은 아키텍처란 '기능이 많은 구조'가 아니라, '문제가 생겨도 버티는 구조'**이다.  
보안과 운영을 설계 초기부터 고려하면, 문제 발생 시 대응 속도와 피해 규모를 최소화할 수 있다.


### 2.6 비용 고려한 의사결정

AWS는 기능도 많고 성능도 좋지만, **잘못 설계하면 요금 폭탄**이 따라온다.  
아키텍처 설계 초기부터 “**이 구조가 과금에 어떤 영향을 줄까?**”라는 질문을 계속 던져야 한다.

* * *

#### 1) 고정비 vs 변동비

| 유형 | 특징 | 예시 |
| --- | --- | --- |
| **고정비** | 항상 일정한 비용 발생 | EC2, RDS, SageMaker 엔드포인트 |
| **변동비** | 사용량에 따라 비용 증가 | Lambda, API Gateway, S3, Athena, Bedrock |

**초기에는 무조건 변동비 구조가 유리하다.**  
사용량이 늘어나면 고정비로 전환하는 방식이 정석이다.

* * *

#### 2) 단일 선택보다 조합으로 판단하자

예를 들어:

*   SageMaker 실시간 엔드포인트는 시간당 과금    
*   대신 Lambda + Bedrock 조합은 호출 단위 과금    

→ 호출량이 적을 땐 Bedrock이 저렴하지만, 일정 이상이면 SageMaker가 유리해진다.

* * *

#### 3) 비용 최적화를 위한 설계 팁

*   **Lambda 실행 시간 줄이기:**  
    코드 최적화 외에도 메모리 설정을 늘려 실행 시간을 단축하면 비용 감소 가능    
*   **API Gateway 대신 ALB 고려:**  
    REST가 아닌 단순 API라면 Application Load Balancer + Lambda 구성이 더 저렴한 경우도 있음    
*   **Athena 쿼리는 압축 + 파티셔닝:**  
    S3에 저장된 데이터를 쿼리할 때, GZIP 압축 + Parquet 포맷 + 파티션 구성으로 스캔 비용 감소    
*   **CloudFront 캐시 전략:**  
    정적 리소스를 최대한 캐싱해 S3와 Lambda 호출을 줄이기    
*   **RI/Graviton 인스턴스 활용:**  
    장기 고정비가 필요한 경우엔 Savings Plans 또는 ARM 기반 인스턴스(R7g 등) 고려
    

* * *
#### 4) 실전 예: 학습 플랫폼의 비용 전략

*   정적 콘텐츠: CloudFront + S3 (캐싱 극대화)    
*   API 호출: 낮은 빈도 → API Gateway + Lambda  
    높은 빈도 → ALB + Fargate로 전환    
*   모델 추론: 학습 진단은 Bedrock, 반복 추론은 SageMaker    
*   데이터 분석: Glue 대신 Athena 위주로 설계 + Parquet 최적화
    

* * *

요약하자면, **비용은 나중에 확인하는 게 아니라, 설계 단계에서 미리 설계하는 항목이다.**  
모든 서비스는 유료이고, **작게 시작하고 점점 바꾸는 전략**이 AWS에선 가장 안전하다.



### 2.7 IaC (Infrastructure as Code) 적용

AWS에서 인프라를 GUI로 클릭해서 만드는 건 빠르지만, **재현이 불가능하고, 협업이 어렵고, 변경 이력이 남지 않는다.**  
그래서 이제는 인프라 역시 코드로 정의하고 관리하는 **IaC (Infrastructure as Code)** 방식이 기본이 되었다.

* * *

#### 1) 왜 IaC를 도입해야 할까?

*   **재현 가능성:** 똑같은 구조를 여러 프로젝트/계정에 배포할 수 있음    
*   **버전 관리:** Git으로 인프라 변경 이력을 추적 가능    
*   **자동화:** 배포 파이프라인에 포함시켜, 클릭 없이 완전 자동 구성    
*   **협업:** 인프라도 코드 리뷰 대상이 됨
    

* * *

#### 2) AWS에서의 IaC 선택지

| 도구 | 특징 |
| --- | --- |
| **CloudFormation** | AWS 기본 제공, YAML/JSON 기반 |
| **CDK (Cloud Development Kit)** | TypeScript, Python 등으로 인프라를 코드로 구성 |
| **Terraform** | 멀티 클라우드 대응 가능, 팀 협업에 강함 |
| **Serverless Framework** | Lambda 중심 프로젝트에 특화된 선언형 구성 도구 |

요즘은 **CDK**를 가장 많이 사용한다. 코드 친화적이고 조건 분기나 반복 로직도 자유롭다.

* * *

#### 3) CDK 실전 예: Lambda + API Gateway 구성

```python
from aws_cdk import aws_lambda, aws_apigateway, core

class MyStack(core.Stack):
    def __init__(self, scope, id, **kwargs):
        super().__init__(scope, id, **kwargs)

        fn = aws_lambda.Function(
            self, "MyFunction",
            runtime=aws_lambda.Runtime.PYTHON_3_9,
            handler="app.handler",
            code=aws_lambda.Code.from_asset("lambda")
        )

        api = aws_apigateway.LambdaRestApi(
            self, "MyApi",
            handler=fn
        )
```

한 번 정의해두면 `cdk deploy` 한 줄로 인프라가 자동 생성된다.

* * *

#### 4) IaC 적용 시 주의할 점

*   **태그 전략 미리 정의하기:** 비용, 보안, 소유자 구분을 위한 필수 요소    
*   **모든 자원에 이름 명시하기:** 콘솔에서 관리하기 쉽게    
*   **리소스 간 의존성 명확히 설정하기:** 순서 보장 및 재배포 안정성 확보
    

* * *

요약하자면, **IaC는 인프라를 "운영"에서 "개발"로 가져오는 도구**다.  
팀 규모가 작아도, 프로젝트가 작아도, IaC로 시작하면 **나중에 무조건 편해진다.**
